// Code generated by sqlc. DO NOT EDIT.
// source: books.sql

package db

import (
	"context"
	"database/sql"
)

const createBook = `-- name: CreateBook :one
INSERT INTO books (
  "title",
  "isbn",
  "publication_year",
  "author_id",
  "publisher_id",
  "genre_id",
  "price",
  "stock_quantity"
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING book_id, title, isbn, publication_year, author_id, publisher_id, genre_id, price, stock_quantity
`

type CreateBookParams struct {
	Title           string         `json:"title"`
	Isbn            string         `json:"isbn"`
	PublicationYear sql.NullInt32  `json:"publication_year"`
	AuthorID        sql.NullInt32  `json:"author_id"`
	PublisherID     sql.NullInt32  `json:"publisher_id"`
	GenreID         sql.NullInt32  `json:"genre_id"`
	Price           sql.NullString `json:"price"`
	StockQuantity   sql.NullInt32  `json:"stock_quantity"`
}

func (q *Queries) CreateBook(ctx context.Context, arg CreateBookParams) (Book, error) {
	row := q.db.QueryRowContext(ctx, createBook,
		arg.Title,
		arg.Isbn,
		arg.PublicationYear,
		arg.AuthorID,
		arg.PublisherID,
		arg.GenreID,
		arg.Price,
		arg.StockQuantity,
	)
	var i Book
	err := row.Scan(
		&i.BookID,
		&i.Title,
		&i.Isbn,
		&i.PublicationYear,
		&i.AuthorID,
		&i.PublisherID,
		&i.GenreID,
		&i.Price,
		&i.StockQuantity,
	)
	return i, err
}

const deleteBook = `-- name: DeleteBook :exec
DELETE FROM books
WHERE book_id = $1
`

func (q *Queries) DeleteBook(ctx context.Context, bookID int64) error {
	_, err := q.db.ExecContext(ctx, deleteBook, bookID)
	return err
}

const getBook = `-- name: GetBook :one
SELECT book_id, title, isbn, publication_year, author_id, publisher_id, genre_id, price, stock_quantity FROM books 
WHERE "book_id" = $1
`

func (q *Queries) GetBook(ctx context.Context, bookID int64) (Book, error) {
	row := q.db.QueryRowContext(ctx, getBook, bookID)
	var i Book
	err := row.Scan(
		&i.BookID,
		&i.Title,
		&i.Isbn,
		&i.PublicationYear,
		&i.AuthorID,
		&i.PublisherID,
		&i.GenreID,
		&i.Price,
		&i.StockQuantity,
	)
	return i, err
}

const listBooks = `-- name: ListBooks :many
SELECT book_id, title, isbn, publication_year, author_id, publisher_id, genre_id, price, stock_quantity FROM books
ORDER BY "title"
LIMIT $1
OFFSET $2
`

type ListBooksParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListBooks(ctx context.Context, arg ListBooksParams) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, listBooks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.BookID,
			&i.Title,
			&i.Isbn,
			&i.PublicationYear,
			&i.AuthorID,
			&i.PublisherID,
			&i.GenreID,
			&i.Price,
			&i.StockQuantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBooksJoin = `-- name: ListBooksJoin :many
SELECT
    b.title AS book_title,
    b.isbn,
    b.publication_year,
    a.first_name AS author_first_name,
    a.last_name AS author_last_name,
    p.publisher_name,
    g.genre_name,
    b.price,
    b.stock_quantity
FROM
    books AS b
INNER JOIN
    authors AS a ON b.author_id = a.author_id
INNER JOIN
    publishers AS p ON b.publisher_id = p.publisher_id
INNER JOIN
    genres AS g ON b.genre_id = g.genre_id
LIMIT $1
OFFSET $2
`

type ListBooksJoinParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListBooksJoinRow struct {
	BookTitle       string         `json:"book_title"`
	Isbn            string         `json:"isbn"`
	PublicationYear sql.NullInt32  `json:"publication_year"`
	AuthorFirstName string         `json:"author_first_name"`
	AuthorLastName  string         `json:"author_last_name"`
	PublisherName   string         `json:"publisher_name"`
	GenreName       string         `json:"genre_name"`
	Price           sql.NullString `json:"price"`
	StockQuantity   sql.NullInt32  `json:"stock_quantity"`
}

func (q *Queries) ListBooksJoin(ctx context.Context, arg ListBooksJoinParams) ([]ListBooksJoinRow, error) {
	rows, err := q.db.QueryContext(ctx, listBooksJoin, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBooksJoinRow
	for rows.Next() {
		var i ListBooksJoinRow
		if err := rows.Scan(
			&i.BookTitle,
			&i.Isbn,
			&i.PublicationYear,
			&i.AuthorFirstName,
			&i.AuthorLastName,
			&i.PublisherName,
			&i.GenreName,
			&i.Price,
			&i.StockQuantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBook = `-- name: UpdateBook :one
UPDATE books
SET 
    "title" = $2,
    "isbn" = $3,
    "publication_year" = $4,
    "author_id" = $5,
    "publisher_id" = $6,
    "genre_id" = $7,
    "price" = $8,
    "stock_quantity" = $9
WHERE   "book_id" = $1
RETURNING book_id, title, isbn, publication_year, author_id, publisher_id, genre_id, price, stock_quantity
`

type UpdateBookParams struct {
	BookID          int64          `json:"book_id"`
	Title           string         `json:"title"`
	Isbn            string         `json:"isbn"`
	PublicationYear sql.NullInt32  `json:"publication_year"`
	AuthorID        sql.NullInt32  `json:"author_id"`
	PublisherID     sql.NullInt32  `json:"publisher_id"`
	GenreID         sql.NullInt32  `json:"genre_id"`
	Price           sql.NullString `json:"price"`
	StockQuantity   sql.NullInt32  `json:"stock_quantity"`
}

func (q *Queries) UpdateBook(ctx context.Context, arg UpdateBookParams) (Book, error) {
	row := q.db.QueryRowContext(ctx, updateBook,
		arg.BookID,
		arg.Title,
		arg.Isbn,
		arg.PublicationYear,
		arg.AuthorID,
		arg.PublisherID,
		arg.GenreID,
		arg.Price,
		arg.StockQuantity,
	)
	var i Book
	err := row.Scan(
		&i.BookID,
		&i.Title,
		&i.Isbn,
		&i.PublicationYear,
		&i.AuthorID,
		&i.PublisherID,
		&i.GenreID,
		&i.Price,
		&i.StockQuantity,
	)
	return i, err
}
